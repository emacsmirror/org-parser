;;; org-structure.el -- parse org files to give an appropriate structure.

;;; Commentary:

;;; Code:

;;;zck should I replace all ^ in regexp with \\`?


(defun org-structure-buffer (buffer)
  "Return the org structure of BUFFER."
  (with-current-buffer buffer
    (org-structure (buffer-string))))

(defun org-structure-file (filename)
  "Return the org structure of FILENAME."
  (with-temp-buffer
    (insert-file-contents filename)
    (org-structure-buffer (current-buffer))))

;; (defun org-structure (text)
;;   "Return the org structure of TEXT."
;;   (org-structure/parse text (org-structure/guess-level text)))

(defun org-structure (text)
  "Return the org structure of TEXT."
  (org-structure/convert-blocked-text (org-structure/block-text (org-structure/split-into-groups text))))

(defun org-structure/split-into-groups (text)
  "Split TEXT into groups; one group for each headline or plain list."
  (let ((current-group "")
        (groups nil))
    (seq-do (lambda (line)
              (if (org-structure/title-line? line)
                  (progn (unless (equal current-group "")
                           (push current-group groups))
                         (setq current-group line))
                (setq current-group
                      (if (equal current-group "")
                          line
                        (format "%s\n%s" current-group line)))))
            (split-string text "\n" t))
    (push current-group groups)
    (reverse groups)))


(defun org-structure/guess-level (text)
  "Attempts to guess the level of the TEXT.

This method will definitely work for headlines,
and will probably work for plain lists.

The situations where this breaks are where there have been multiple
ordered lists in parents for TEXT, as the bullet for ordered lists
is more than one character."
  (cond ((string-match "^\\(\\*+\\) " text)
         (length (match-string 1 text)))
        ((string-match "^\\(\s*\\)[-+[:digit:]]" text)
         (1+ (/ (length (match-string 1 text)) 2)))
        (t 1)))


(defun org-structure/bullet-type (full-bullet)
  "Return the bullet-type of FULL-BULLET.

For example, \"** \" has a bullet type of ?*.
Plain lists are the leading symbol (+ or -).
Ordered lists are ?. or ?)"
  (cond ((string-match "^\\*+ " full-bullet)
         ?*)
        ((string-match "^\s*\\([+-]\\) " full-bullet)
         (elt (match-string 1 full-bullet) 0))
        ((string-match "^\s*[[:digit:]]+\\([.)]\\) " full-bullet)
         (elt (match-string 1 full-bullet) 0))))


(defun org-structure/convert-blocked-text (blocked-text)
  "Convert BLOCKED-TEXT, a list generated by block-text, to a list of org structures."
  (mapcar #'org-structure/convert-text-block
          blocked-text))

(defun org-structure/convert-text-block (text-block)
  "Convert TEXT-BLOCK to an org structure.

Return a single structure.  A structure has the following keywords:

:text -- the text on the first line of the block.
:body -- the text on following lines of the block, as a string with newlines.
    For example:
    * this is the 'text'
      This is the 'body', which can
      continue to multiple lines.
:children -- a list of child blocks.
:bullet-type -- a character indicating the type of bullet used,
    either ?*, ?-, ?+, ?., or ?) .  For ordered lists --
    (either ?\) or ?.) -- this is the character /after/ the number.
    For other types of blocks, the bullet is the entire number."
  (let ((table (make-hash-table))
        (text (car text-block)))
    (puthash :text (org-structure/get-text text) table)
    (puthash :body (org-structure/get-body text) table)
    (puthash :bullet-type (org-structure/bullet-type text) table)
    (puthash :children (org-structure/convert-blocked-text (cdr text-block)) table)
    table))

(defun org-structure/get-text (text)
  "Return TEXT without the bullet."
  (cond ((string-match "\\`\\*+ \\(.+\\)" text)
         (match-string 1 text))
        ((string-match "\\` *[-+*] \\(.+\\)" text)
         (match-string 1 text))
        ((string-match "\\` *[[:digit:]]+[.)] \\(.+\\)" text)
         (match-string 1 text))))

(defun org-structure/get-body (text)
  "Return the body of a given TEXT.

This method will drop initial newlines, then treat everything after a newline as the body."

  (let ((lines (split-string text "\n" t)))
    (when (cdr lines)
      (string-join (cdr lines)
                   "\n"))))

(defun org-structure/block-text (lines)
  "Block the given LINES into its overall structure.

Return a list that represents the structure of LINES.  Each element is either
a list or a string."
  (when lines
    (let* ((first-line (car lines))
           (first-block (seq-take-while (lambda (line)
                                          (org-structure/same-block? first-line line))
                                        (cdr lines))))
      (cons (cons first-line
                  (org-structure/block-text first-block))
            (org-structure/block-text (seq-drop lines
                                                (+ 1 (length first-block))))))))

(defun org-structure/same-block? (original-line current-line)
  "Whether ORIGINAL-LINE and CURRENT-LINE should be in the same block.

For example, a block that starts '* headline' should be in the same block
 at '** nested', but not the same block as '* another headline.'"
  (if (org-structure/headline? original-line)
      (or (and (org-structure/headline? current-line)
               (< (org-structure/guess-level original-line)
                  (org-structure/guess-level current-line)))
          (org-structure/plain-list? current-line))
    (and (org-structure/plain-list? current-line)
         (< (org-structure/guess-level original-line)
            (org-structure/guess-level current-line)))))

(defun org-structure/title-line? (line)
  "Return whether LINE corresponds to a title line.

A title line is the first line of a headline or plain list."

  (or (org-structure/headline? line)
      (org-structure/plain-list? line)))

(defun org-structure/headline? (line-or-char)
  "Return t if LINE-OR-CHAR is a headline.

LINE-OR-CHAR can be either a line, or the character in a structure
indicating the bullet type."
  (if (characterp line-or-char)
      (equal line-or-char ?*)
    (and (> (length line-or-char)
            0)
         (equal (elt line-or-char 0)
                ?*))))

(defun org-structure/plain-list? (line-or-char)
  "Return t if LINE-OR-CHAR is a plain list.

LINE-OR-CHAR can be either a line, or the character in a structure
indicating the bullet type."
  (if (characterp line-or-char)
      (not (org-structure/headline? line-or-char))
    (and (> (length line-or-char)
            0)
         (or (org-structure/ordered-list? line-or-char)
             (string-match "\\`\s*[-*+] " line-or-char))
         (not (org-structure/headline? line-or-char)))))

(defun org-structure/ordered-list? (line-or-char)
  "Return t if LINE-OR-CHAR is an ordered list.

LINE-OR-CHAR can be either a line, or the character in a structure
indicating the bullet type."
  (if (characterp line-or-char)
      (or (= ?. line-or-char)
          (= ?\) line-or-char))
    (and (string-match "\\` *[[:digit:]]+[.)] " line-or-char) t)))

(defun org-structure/make-bullet (structure parent-bullet older-sibling-count)
  "Return the string representing the bullet for STRUCTURE.

PARENT-BULLET is used to determine indentation.

There should be OLDER-SIBLING-COUNT siblings before this one.  This only matters for ordered lists."
  (cond ((org-structure/headline? (gethash :bullet-type structure))
         ;;we have a headline, so we must be under a headline (right?)
         (if (string-match "\\`\\(\\*+ \\)$" parent-bullet)
             (format "*%s" (match-string 1 parent-bullet))
           "* "))
        ((org-structure/ordered-list? (gethash :bullet-type structure))
         (format "%s%d%c "
                 (org-structure/get-nested-whitespace parent-bullet)
                 (1+ older-sibling-count)
                 (gethash :bullet-type structure)))
        ((org-structure/plain-list? (gethash :bullet-type structure))
         ;;plain lists can be under headlines, or under other plain lists
         (if t ;; (org-structure/headline? parent-bullet)
             (format "%s%c "
                     (org-structure/get-nested-whitespace parent-bullet)
                     (gethash :bullet-type structure))))
        (t 'whaaat?)))

(defun org-structure/get-nested-whitespace (bullet)
  "Gets the nested whitespace for a plain list under BULLET.

BULLET can be the bullet for a plain list or a headline."
  (if (org-structure/headline? bullet)
      ""
    (if (string-match "\\`\\(\s*[^\s]+\\)\s" bullet)
        (make-string (1+ (length (match-string 1 bullet)))
                     ?\s)
      "")))

(defun org-structure/to-string (structure-list)
  "Convert STRUCTURE-LIST, a list of structure hash tables, to a string.

This should be identical to the org file parsed to create the structure."
  (org-structure/to-string-helper structure-list ""))

(defun org-structure/to-string-helper (structure-list parent-bullet)
  "Convert STRUCTURE-LIST, a list of structure hash tables, to a string.

These structure hash tables all have the same parent, whose bullet
is PARENT-BULLET.

This should be identical to the org file parsed to create the structure."
  (string-join (cl-mapcar (lambda (structure siblings-before-this-one)
                            (org-structure/single-to-string structure parent-bullet siblings-before-this-one))
                          structure-list
                          (number-sequence 0
                                           (1- (length structure-list))))))

(defun org-structure/single-to-string (structure parent-headline siblings-before-this-one)
  "Create the string for STRUCTURE, with parent having PARENT-HEADLINE.

SIBLINGS-BEFORE-THIS-ONE is the count of older siblings with the same parent."
  (let* ((this-bullet (org-structure/make-bullet structure parent-headline siblings-before-this-one))
         (title-line (format "%s%s"
                             this-bullet
                             (gethash :text structure)))
         (children-text (org-structure/to-string-helper (gethash :children structure)
                                                        this-bullet)))
    (if (gethash :body structure)
        (format "%s\n%s\n%s" title-line (gethash :body structure) children-text)
      (format "%s\n%s" title-line children-text))))


(defun org-structure/get-nested-children (structure &rest children-indices)
  "Get children recursively from STRUCTURE; at each level, take the nth child, where n is the next element in CHILDREN-INDICES."
  (if (not children-indices)
      structure
    (apply #'org-structure/get-nested-children
           (elt (gethash :children structure)
                (first children-indices))
           (rest children-indices))))

(defun org-structure/get-bullet (text)
  "Get the bullet form from TEXT, including the space after.

If TEXT does not start with a bullet form, this will error."
  (cond ((string-match "\\`\\(\\*+ \\)" text)
         (match-string 1 text))
        ((string-match "\\`\\(\s*[+-] \\)" text)
         (match-string 1 text))
        ((string-match "\\`\\(\s*[[:digit:]]+[.)]\s\\)" text)
         (match-string 1 text))
        (t (error "Error calling org-structure/get-bullet on a string that doesn't have bullets"))))

;;; org-structure.el ends here
